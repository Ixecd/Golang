package main

import "fmt"
import "time"


func testChannel1() {
	// 不要通过共享内存来通信,而应该通过通信来共享内存,为了安全
	ch := make(chan int)
	// chh := make(chan int,100) // 声明一个容量为100的管道
	go func() {
		ch <- 1
	}()
	fmt.Println(<-ch)
}
/*
	前导知识:
	- 管道类型的值本事就是并发安全的,这是Go语言自带的/唯一一个可以满足并发安全性的类型
	- 在声明并初始化一个管道的时候,需要使用到Go语言的内建函数make(),就像使用make初始化切片那样,我们传给这个函数的第一个参数应该是代表了通道的类型的类型字面量,表示管道的大小
	- 当管道的大小为0时,可以称管道为非缓冲管道,也就是不到缓冲的管道,当容量大于0时,可以称为缓冲管道

	- 一个管道相当于一个FIFO队列,管道中的元素值都是严格地按照发送地顺序排列地,先被发送地数据一定会被先被接收,元素值地发送和接受都需要使用操作符->/<-,我们也可以叫他接送操作符,代表数据流向地方向
*/

func testChannel2() {
	// ch1 := make(chan int) // 这里没有指定管道的大小,所以默认是非缓冲管道
	// 在非缓冲通道中,其特点时发送和接收操作必须同步进行,发送方在发送数据前会被阻塞,直到有接收方准备接受数据为止
	// 所以下面的代码会在 ch1 <- 1 之前一直阻塞,直到有接收方准备接收数据才会执行
	ch1 := make(chan int, 3)
	ch1 <- 1 // main函数本身也是一个goroutine,如果采用非缓冲管道,则会阻塞在这里,直到有接收方准备接收数据才会由操作系统来唤醒main goroutine继续执行
	ch1 <- 2
	ch1 <- 3
	time.Sleep(1 * time.Second)
	elem1 := <-ch1
	elem2 := <-ch1
	elem3 := <-ch1
	fmt.Printf("The First Element received from channel ch1: %v\n", elem1)
	fmt.Printf("The Second Element received from channel ch1: %v\n", elem2)
	fmt.Printf("The Third Element received from channel ch1: %v\n", elem3)

}
/*
	管道的基本特性:
		- 对于同一个管道,发送操作之间时互斥的,接收操作之间也是互斥的
		- 发送操作和接受操作中队元素值的处理都是不可分割的
		- 发送操作在完全完成之前会被阻塞,接收操作也是如此

		- 所谓的管道并发执行,是指多个代码块分别在不同的goroutine中,并有机会在同一个时间段内被执行
		- 对于管道中的同一个元素值来说,发送操作和接受操作之间也是互斥的,
		- 虽然会出现,正在被赋值进管道但还未赋值完成的元素值,但是这时它绝不会被想接收它的一方看到或使用

		- 这里要注意一个细节,元素值从外界进入管道时会被复制,更具体而言,进入管道的并不是在接受操作符右边的那个元素值,而是它的副本
		- 另一方面,元素值从管道进入外界时会被移动,这个移动操作分为两部分,第一步时生成正在通道中的这个元素值的副本,并准备给到接收方,第二步是删除在管道中的这个元素

		- 对于值为nil的管道,不论它的类型是什么,对他的操作都永久地处于阻塞状态
*/

// func main() {

// 	testChannel1()
// 	testChannel2()
	
// }